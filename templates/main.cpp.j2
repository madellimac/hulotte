{% if not use_streampu %}
#include <iostream>

int main(int argc, char** argv)
{
    std::cout << "Starting Hulotte project (Basic C++)..." << std::endl;
    // Add your code here
    return 0;
}
{% else %}
#include <iostream>
#include <vector>
#include <fstream>
#include <streampu.hpp>
{% if use_aff3ct %}
#include <aff3ct.hpp>
{% endif %}
{% if use_hw %}
#include "VerilatorSimulation.hpp"
#include "VModel_Direct.h" // Generated by Verilator for Direct Mode
#include "VModel_UART.h"   // Generated by Verilator for UART Mode
{% endif %}
{% if use_custom %}
#include "custom/MyModule.hpp"
{% endif %}

using namespace spu;
using namespace spu::module;

int main(int argc, char** argv)
{
    std::cout << "Starting Hulotte project..." << std::endl;

{% if use_aff3ct %}
    // 1. Modules creation
    
    // RS(7, 5) => t=1, m=3. Bits 21 -> 15.
    // NOTE: This uses aff3ct B_32 (32-bit integer) template instantiation.
    const int N_rs = 7;  // Symbols
    const int K_rs = 5;  // Symbols
    const int m = 3;       // Bits per symbol
    const int t = (N_rs - K_rs) / 2; // Correction 
    const int N = N_rs * m; // Total bits
    const int K = K_rs * m; // Info bits

    module::Source_random<> source(K);
    module::Finalizer    <> finalizer(K);
    
    // Create RS Polynomial Generator (needed for RS construction)
    aff3ct::tools::RS_polynomial_generator poly(N_rs, t);
    
    // Create Encoder and Decoder
    aff3ct::module::Encoder_RS<>     encoder(K_rs, N_rs, poly);
    aff3ct::module::Decoder_RS_std<> decoder(K_rs, N_rs, poly);    

    {% if use_custom %}
    module::MyModule         my_module(K);
    {% endif %}
    {% if use_hw %}
    // Create both Direct and UART simulation modes
    module::VerilatorSimulation<VModel_Direct> verilator_sim_direct(K, false, "trace_direct");
    module::VerilatorSimulation<VModel_UART>   verilator_sim_uart  (K, true,  "trace_uart");
    {% endif %}

    // 2. Sockets binding
    using namespace aff3ct::module;
    using namespace aff3ct::tools;
    
    // Chain construction
    {% if use_hw %}
    // Chain: Source -> UART -> Direct -> (Custom Module) -> Encoder
    source   [src::tsk::generate][(int)src::sck::generate::out_data] = verilator_sim_uart  ["simulate::input"];
    verilator_sim_uart      ["simulate::output"]   = verilator_sim_direct["simulate::input"];
    {% if use_custom %}
    verilator_sim_direct    ["simulate::output"]   = my_module           ["process::in"];
    my_module               ["process::out"]       = encoder             [enc::tsk::encode][(int)enc::sck::encode::U_K];
    {% else %}
    verilator_sim_direct    ["simulate::output"]   = encoder             [enc::tsk::encode][(int)enc::sck::encode::U_K];
    {% endif %}
    {% else %}
    // Chain: Source -> (Custom Module) -> Encoder
    source   [src::tsk::generate][(int)src::sck::generate::out_data] = 
    {% if use_custom %}
    my_module ["process::in"];
    my_module ["process::out"] = 
    {% endif %}
    encoder  [enc::tsk::encode][(int)enc::sck::encode::U_K];
    {% endif %}

    encoder  [enc::tsk::encode][(int)enc::sck::encode::X_N]        = decoder  [dec::tsk::decode_hiho][(int)dec::sck::decode_hiho::Y_N];
    decoder  [dec::tsk::decode_hiho][(int)dec::sck::decode_hiho::V_K] = finalizer["finalize::in"];

{% else %}
    // 1. Modules creation
    
    const int n_elmts = 16;
    module::Source_random<int> source(n_elmts);
    module::Finalizer  <int> finalizer(n_elmts);
    {% if use_custom %}
    module::MyModule         my_module(n_elmts);
    {% endif %}
    {% if use_hw %}
    // Create both Direct and UART simulation modes
    module::VerilatorSimulation<VModel_Direct> verilator_sim_direct(n_elmts, false, "trace_direct");
    module::VerilatorSimulation<VModel_UART>   verilator_sim_uart  (n_elmts, true,  "trace_uart");
    {% endif %}
    
    // 2. Sockets binding
    {% if use_hw %}
    // Chain: Source -> UART (slow/sim) -> Direct (fast) {% if use_custom %}--> Custom Module {% endif %}--> Finalizer
    source                  ["generate::out_data"] = verilator_sim_uart  ["simulate::input"];
    verilator_sim_uart      ["simulate::output"]   = verilator_sim_direct["simulate::input"];
    {% if use_custom %}
    verilator_sim_direct    ["simulate::output"]   = my_module           ["process::in"];
    my_module               ["process::out"]       = finalizer           ["finalize::in"];
    {% else %}
    verilator_sim_direct    ["simulate::output"]   = finalizer           ["finalize::in"];
    {% endif %}
    {% else %}
    // Chain: Source {% if use_custom %}--> Custom Module {% endif %}--> Finalizer
    source  ["generate::out_data"] = {% if use_custom %}my_module ["process::in"];
    my_module ["process::out"] = {% endif %}finalizer ["finalize::in"];
    {% endif %}
{% endif %}

    // 3. Sequence creation
    std::vector<runtime::Task*> first_tasks;
{% if use_aff3ct %}
    first_tasks.push_back(&source("generate"));
{% else %}
    first_tasks.push_back(&source("generate"));
{% endif %}

    runtime::Sequence sequence(first_tasks);

    // Configuration
    for (auto& type : sequence.get_tasks_per_types())
        for (auto& t : type)
        {
            t->set_stats(true);
            t->set_debug(false);
        }

    // 4. Execution
    std::cout << "Processing..." << std::endl;
    
    // Export dot file for visualization
    std::ofstream file("graph.dot");
    sequence.export_dot(file);

    // Run the sequence
    for (auto i = 0; i < 3; i++)
        sequence.exec_seq(); // Run 1 frame at a time

    // 5. Stats
    std::cout << "\\nEnd of execution." << std::endl;
    tools::Stats::show(sequence.get_tasks_per_types(), true, false);

    return 0;
}
{% endif %}
