#ifndef VERILATORSIMULATION_HPP
#define VERILATORSIMULATION_HPP

#include <verilated.h>
#include <verilated_vcd_c.h>
#include <iostream>
#include <streampu.hpp> 

namespace spu
{
namespace module
{

/**
 * Template class for Verilator simulation wrapper
 * VModelType: The specific Verilator generated class (e.g., VModel_UART, VModel_Direct)
 * 
 * Usage:
 *    module::VerilatorSimulation<VModel_Direct> sim_direct(frame_size, false, "trace_direct"); 
 *    module::VerilatorSimulation<VModel_UART>   sim_uart(frame_size, true, "trace_uart");
 */
template <typename VModelType>
class VerilatorSimulation : public Stateful {

private:
    VModelType* dut = nullptr; // Pointer to the generated Verilator model specific to this template
    VerilatedVcdC* m_trace = nullptr;
    VerilatedContext* m_context = nullptr; // Own Verilator context for isolation
    vluint64_t sim_time = 0;
    
    int frame_size;
    bool use_uart;   // Runtime flag to know which interface signals to use/monitor

    bool is_reset_time() { return (sim_time < 7); }
    bool is_rising_edge() { return (sim_time % 2 == 0); }
    bool is_falling_edge() { return (sim_time % 2 != 0); }

public:
    // **Constructor**
    // frame_size: Size of data frame to process
    // use_uart_mode: If true, the wrapper logic will drive UART signals (pc_tx/pc_rx).
    // trace_name: Custom name for the VCD output simulation file. If empty, a default name is generated.
    VerilatorSimulation(int frame_size, bool use_uart_mode = false, const std::string& trace_name = "") 
    : Stateful(), frame_size(frame_size), use_uart(use_uart_mode) 
    {
        // 1. Create a dedicated context for this simulation instance
        m_context = new VerilatedContext;
        m_context->traceEverOn(true); // Enable tracing on this context
        
        // 2. Instantiate the model using this context
        dut = new VModelType{m_context}; 

        m_trace = new VerilatedVcdC;
        dut->trace(m_trace, 5);
        
        // Trace file naming logic
        std::string final_trace_name;
        if (trace_name.empty()) {
            std::string mode_str = use_uart ? "UART" : "Direct";
            final_trace_name = "waveform_" + mode_str + "_" + std::to_string((uintptr_t)this) + ".vcd";
        } else {
            final_trace_name = trace_name + ".vcd";
        }

        m_trace->open(final_trace_name.c_str());
        
        // Module naming logic
        std::string mode_short_str = use_uart ? "_UART" : "_Direct";
        this->set_name("VerilatorSimulation" + mode_short_str);
        if(!trace_name.empty()){
             this->set_short_name(trace_name); 
        } else {
             this->set_short_name("VerilatorSim");
        }
        
        auto &t = create_task("simulate");
        auto input  = create_socket_in<int>(t, "input", frame_size);
        auto output = create_socket_out<int>(t, "output", frame_size);

        this->create_codelet(t, [input, output](Module &m, runtime::Task &t, const size_t frame_id) -> int {
            static_cast<VerilatorSimulation<VModelType>&>(m).simulate(
                static_cast<int*>(t[input].get_dataptr()),
                static_cast<int*>(t[output].get_dataptr()),
                frame_id
            );
            return 0;
        });
    }

    virtual ~VerilatorSimulation() {
        if (m_trace) {
            m_trace->close();
            delete m_trace;
        }
        if (dut) {
            delete dut;
        }
        if (m_context) {
            delete m_context;
        }
    }

protected:
    void simulate(const int* input, int *output, const int frame_id) {
        int input_data_count = 0;
        int output_data_count = 0;

        enum t_state { wait, shift_in, shift_out, over };
        t_state c_state, n_state = wait;
        
        while(output_data_count < frame_size) {
            
            // --- TIME & RESET HANDLING ---
            if(is_reset_time()){
                dut->reset = 1;
                // Initialize inputs
                // Note: These signals MUST exist in VModelType.
                // If compiled without UART, pc_tx_en technically doesn't go anywhere inside,
                // but Verilator usually keeps top-level ports even if unconnected inside.
                // However, to be safe, we assume the Universal Top has these ports always.
                dut->direct_in_valid = 0;
                dut->pc_tx_en = 0; 
            }
            else if(is_rising_edge()){
                dut->reset = 0;       
                c_state = n_state;     
            }
            else if(is_falling_edge()){
                dut->reset = 0;
                
                // --- OUTPUT READING ---
                bool data_valid = false;
                int  data_val = 0;
                
                if (use_uart) {
                    // Logic for UART mode reading
                    data_valid = dut->pc_rx_valid;
                    data_val   = dut->pc_rx_byte;
                } else {
                    // Logic for Direct mode reading
                    data_valid = dut->direct_out_valid;
                    data_val   = dut->direct_out_data;
                }

                if (data_valid) {
                    if (output_data_count < frame_size) {
                        output[output_data_count++] = data_val;
                    }
                }

                // --- INPUT WRITING ---
                bool sent_success = false;
                
                if (input_data_count < frame_size) {
                    // We have data to send
                    int val_to_send = input[input_data_count];
                    
                    if (use_uart) {
                        // UART: Must check busy signal
                        if (!dut->pc_uart_busy) {
                            dut->pc_tx_en = 1;
                            dut->pc_tx_byte = val_to_send;
                            sent_success = true;
                        } else {
                             dut->pc_tx_en = 0;
                        }
                    } else {
                        // Direct: Assume always ready (or check ready if you add it later)
                        dut->direct_in_valid = 1;
                        dut->direct_in_data = val_to_send;
                        sent_success = true; 
                    }
                } else {
                    // No more data
                    dut->pc_tx_en = 0;
                    dut->direct_in_valid = 0;
                }
                
                if (sent_success) {
                       input_data_count++;
                }

            } // End falling edge logic
            
            // Toggle clock
            dut->clk ^= 1;
            dut->eval();
            
            if (m_trace) m_trace->dump(sim_time);
            sim_time++;
        }
    }
};

} // namespace module
} // namespace spu

#endif // VERILATORSIMULATION_HPP
