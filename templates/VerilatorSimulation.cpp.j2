#include <stdlib.h>
#include <iostream>
#include <verilated.h>          
// On inclut le header généré par Verilator pour le nouveau module top
#include "Vuniversal_simulation_top.h"       
#include "VerilatorSimulation.hpp"

using namespace spu;
using namespace spu::module;

    VerilatorSimulation::VerilatorSimulation(int frame_size, bool use_uart) 
    : Stateful(), frame_size(frame_size), use_uart(use_uart) 
    {

        // Instanciation du nouveau wrapper
        dut = new Vuniversal_simulation_top;  

        Verilated::traceEverOn(true);
        m_trace = new VerilatedVcdC;
        dut->trace(m_trace, 5);
        m_trace->open("waveform.vcd");
        
        this->set_name("VerilatorSimulation");
        this->set_short_name("VerilatorSimulation");

        auto &t = create_task("simulate");

        auto input    = create_socket_in<int>(t, "input", frame_size);
        auto output   = create_socket_out<int>(t, "output", frame_size);

        this->create_codelet(t, [input, output](Module &m, runtime::Task &t, const size_t frame_id) -> int {
        static_cast<VerilatorSimulation&>(m).simulate(  static_cast<int*>(t[input].get_dataptr()),
                                                        static_cast<int*>(t[output].get_dataptr()),
                                                        frame_id);
        return 0;
    });

    }

    VerilatorSimulation::~VerilatorSimulation() {
        m_trace->close();
        delete m_trace;
        delete dut;
        // exit(EXIT_SUCCESS);
    }    

    void VerilatorSimulation::simulate(const int* input, int *output, const int frame_id) {
        
        int input_data_count = 0;
        int output_data_count = 0;

        enum t_state { wait, shift_in, shift_out, over };
        t_state c_state, n_state = wait;
        int i =0;
        int init_time = sim_time;
        int val;

        // while (sim_time < 10000) {
        while(output_data_count < frame_size) {
            
            // --- CONFIGURATION DU MODE (Runtime) ---
            // Le paramètre USE_UART est fixé à la compilation du modèle Verilator
            // dut->use_uart = this->use_uart; // REMOVED: use_uart is now a parameter
            
            if(is_reset_time()){
                dut->reset = 1;
                // Init inputs to 0
                dut->direct_in_valid = 0;
                dut->pc_tx_en = 0; 
            }
            else if(is_rising_edge()){
                dut->reset = 0;       
                c_state = n_state;     
            }
            else if(is_falling_edge()){
                dut->reset = 0;
                
                // --- OUTPUT HANDLING (Mode Direct) ---
                // En mode direct, on lit directement direct_out_data/valid.
                // En mode UART "universel", le PC simulé a ses propres signaux pc_rx_byte/valid.
                
                // Mais wait ! Si on utilise l'UART, on veut que le "output" de ce block soit ce qui arrive au PC !
                // Universal wrapper sort :
                // 1. direct_out_data (sortie du user core) -> TOUJOURS ACTIF
                // 2. pc_rx_byte (sortie du UART Host) -> ACTIF SEULEMENT SI UART CONNECTÉ
                
                // Pour faire simple et unifié :
                // Si use_uart == true, on regarde pc_rx_byte/valid
                // Si use_uart == false, on regarde direct_out_data/valid
                
                bool data_ready = false;
                int  data_val = 0;
                
                if (use_uart) {
                    data_ready = dut->pc_rx_valid;
                    data_val   = dut->pc_rx_byte;
                } else {
                    data_ready = dut->direct_out_valid;
                    data_val   = dut->direct_out_data;
                }

                if (data_ready) {
                    if (output_data_count < frame_size) {
                        output[output_data_count++] = data_val;
                    }
                }

                // --- INPUT HANDLING ---
                
                bool sent_success = false;
                
                if (input_data_count < frame_size) {
                    int val_to_send = input[input_data_count];
                    
                    if (use_uart) {
                        // On envoie au PC simulé qui va envoyer au FPGA
                        // Il faut attendre que l'UART Host soit prêt (pas busy)
                        if (!dut->pc_uart_busy) {
                            dut->pc_tx_en = 1;
                            dut->pc_tx_byte = val_to_send;
                            sent_success = true;
                        } else {
                             dut->pc_tx_en = 0;
                        }
                    } else {
                        // Injection directe
                        dut->direct_in_valid = 1;
                        dut->direct_in_data = val_to_send;
                        sent_success = true; // On assume toujours prêt en direct dans ce template simple
                    }
                } else {
                    dut->pc_tx_en = 0;
                    dut->direct_in_valid = 0;
                }
                
                if (sent_success) {
                       input_data_count++;
                }

            }
            
            dut->clk ^= 1;
            dut->eval();

            m_trace->dump(sim_time);

            sim_time++;
           
        }
    }

    // Ajoutez d'autres méthodes pour contrôler votre simulation au besoin


    bool VerilatorSimulation::is_reset_time(){
        return (sim_time < 7);
    }

    bool VerilatorSimulation::is_rising_edge(){
        return (sim_time%2 == 0);
    }

    bool VerilatorSimulation::is_falling_edge(){
        return (sim_time%2 != 0);
    }